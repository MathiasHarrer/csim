% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/csim-main.R
\name{csim}
\alias{csim}
\title{A Constrained single index model  (main function)}
\usage{
csim(y, Tr, X, ortho.constr = TRUE, sparse = TRUE, type = "AIC",
  seed = 1234, lam.by = 0.03, n.lam = 100, n.max = 10,
  eps = 10^-4, it.max = 70, trace = F, nbasis.t = NULL,
  rho.grid = c(0, 0.25, 0.5), eff.aug = FALSE, X.aug = NULL,
  linear.link = FALSE, coef.ini = NULL, i.fx = NULL,
  mc.ini = FALSE, unit.norm = FALSE, plots = TRUE, boot.CI = FALSE,
  n.boot = 500)
}
\arguments{
\item{y}{treatment outcomes, n-by-1 vector}

\item{Tr}{treatment indicators, n-by-1 vector; each element represents one of the K available treatment options}

\item{X}{a pretreatment covarate matrix, n-by-p matrix}

\item{ortho.constr}{the constraint that separates the interaction effects from the main effect (without this, the interaction effect can be confounded by the main effect); the default is \code{TRUE}.}

\item{sparse}{if \code{TRUE}, apply L1 regularization when estimating the single index coefficients; the default is \code{TRUE}.}

\item{type}{when  \code{sparse=TRUE}, can choose bewteen \code{"CV"} and \code{"BIC"}, for the sparsity tuninig parameter selection.}

\item{seed}{when  \code{type="CV"}, randomization seed for cross validation.}

\item{lam.by}{a value specifying the grid of the sparsity tuning parameters [1, 1+lam.by, ... 1 + n.lam*lam.by].}

\item{n.lam}{a value specifying the grid of the sparsity tuning parameters [1, 1+lam.by, ... 1 + n.lam*lam.by].}

\item{n.max}{a maximum number of nonzero (active) coeffients in CSIM.}

\item{eps}{a value specifying the converge criterion of algorithm.}

\item{it.max}{an integer value specifying the maximum number of iterations for each coordinate.}

\item{trace}{if \code{TRUE}, show the trace of the fitting procedure; the default is \code{FALSE}.}

\item{nbasis.t}{a length K+1 vector; each element specifies the number of B-spline basis funtions for approximating the treatment-specific link function; the last element is for the "main effect" link function; the default is \code{nbasis.t=NULL}, and will be determined depending on the sample size.}

\item{rho.grid}{a grid vector of (ridge-type) smoothing parameters for approximating the link functions.}

\item{eff.aug}{if \code{TRUE}, perform efficiency augmentation (using a L1 regularized linear regression for the main effects of X); the default is \code{FALSE}.}

\item{X.aug}{a design matrix to be used for efficinecy augmentation; the default is \code{NULL}.}

\item{linear.link}{if \code{TRUE}, restrict the link functions to be linear functions; the default is \code{FALSE}.}

\item{coef.ini}{an initial solution for alpha.coef; the default is \code{NULL}.}

\item{i.fx}{an index to be fixed throughout estimation for model identifiability; the default is \code{NULL}.}

\item{mc.ini}{if \code{TRUE}, use an estimate obtained from the modified covariate method as an initial solution; this is only applicable for K=2 case; the default is \code{FALSE}.}

\item{unit.norm}{if \code{TRUE}, set the estimated coefficient vector to have a unit norm for model identifiability; the default is to set the component with the largest magnitude to be 1.}

\item{plots}{if \code{TRUE}, produce a plot of the estimated link functions and the coefficient estimate.}

\item{boot.CI}{if \code{TRUE}, return a \code{boot} object that can be used to construct bootstrap confidence intervals for the single index coefficients; the default is \code{FALSE}.}

\item{n.boot}{when \code{boot.CI=TRUE}, a value specifying the number of bootstrap replications.}
}
\value{
a list of information of the final fitted model including
\item{coef.obj}{an object containing information about the estimated coefficients.} \item{link.fn.obj}{an object containing information about the estimated link functions.} \item{alpha.coef}{ the estimated single index coefficients.} \item{eta.coef}{the  estimated  main effect coefficients if \code{eff.aug=TRUE}.} \item{beta.t.coef}{the list of the estimated treatment-specific B-spline coefficient vectors.} \item{beta.0.coef}{the estimated B-spline coefficient vector for the main effect of the single index variable.} \item{smoother}{an object containing information about the estimated link functions, including the knot sequences used in the B-spline approximation \code{knots.t.}} \item{link.fn.plot}{a plot object for the link functions.} \item{coef.plot}{a plot object for the single index coefficients.} \item{boot.results}{a \code{boot} object that can be used to construct bootstrap  confidence intervals for the single index coefficients.}
}
\description{
\code{csim} is the main function for fitting the constrained single index model (CSIM).
\code{csim} uses pre-treatment covariates X for modeling a scalar-valued treatment outcome y.
The single index variable is defined to be a linear combinations of X.
The differential treatment effect is estimated by treatment-specific nonparametrically-defined link functions on the single index variable.
For simultaneous variable selection for the treatment effect modifiers,
 \code{csim} estimates a sparse single index coefficient vector via a \eqn{L1} regularization.
The estimated single index variable is useful for comparing differential treatment efficacy;
the resulting \code{csim} object can be used to estimate an optimal treatment selection rule
for a new patient with pretreatment clinical information.
}
\details{
The sequence of the model coefficients implied by the tuning paramters \code{lam} is fit by block coordinate descent algorithm.
}
\examples{
## generate a training set
dat.train <- dataGenerationFn(n=500, p=500, w=3, delta = 1);
y.train <- dat.train$y;
Tr.train <- dat.train$Tr;
X.train <- dat.train$X

## generate a  testing set, under the same setting as in the trainint set.
dat.test <- dataGenerationFn(n=10000, p= dat.train$p, w= dat.train$w, delta = dat.train$delta,
                             true.alpha = dat.train$true.alpha, true.eta = dat.train$true.eta);
y.test <- dat.test$y;
Tr.test <- dat.test$Tr;
X.test <- dat.test$X;

# the "signal" to "noise"  ratio (SNR)
dat.test$SNR
# the optimal treatment selection rule
optTr <- dat.test$optTr
value.opt <- dat.test$value.opt
# the true single index coefficients
true.alpha <- dat.test$true.alpha


# 1. fit a constrained single index model, based on the training set
csim.obj   <- csim(y.train, Tr.train, X.train, type = "AIC", rho.grid =0, eff.aug = FALSE)
csim.obj$alpha.coef
# compare the estimate to the true single index coefficients
true.alpha

## can also perform a 5 fold cross validation
#csim.obj2  <- csim(y.train, Tr.train, X.train, type = "CV", rho.grid =0, eff.aug = FALSE)
#csim.obj2$alpha.coef
## can also obtain an un-regularized estimator.
#csim.obj3   <- csim(y.train, Tr.train, X.train, sparse = FALSE, rho.grid =0, eff.aug = FALSE)
#csim.obj3$alpha.coef

## performance assessment:
# y.test, Tr.test, X.test are testing data
pred.test <- pred.csim(csim.obj, X.test)$pred.new
performance.obj <- performance_measure(pred.test, y.test, Tr.test, value.opt, optTr)

# proprortion of correct decisions
performance.obj$pcd;
# the ratio of the Value of ITR (i.e., Value/ Value.opt)
performance.obj$value.s;
# proportion of correctly (C.) selected treatment effect modifiers:
sum(csim.obj$alpha.coef[true.alpha!=0] != 0) /sum(true.alpha!=0);
# proportion of covariates incorrectly (I.C.) selected as treatment effect modifiers:
sum(csim.obj$alpha.coef[!(true.alpha!=0)] != 0)/ sum(true.alpha==0);


# 2. fit a modified covariate model (with efficiency augmentation)
mc.obj <- mc(y.train, Tr.train, X.train, eff.aug  = TRUE, use.lasso=TRUE)
mc.obj$alpha.coef

pred.test <- pred.mc(mc.obj, X.test)$pred.new
performance.obj <- performance_measure(pred.test, y.test, Tr.test, value.opt, optTr)
performance.obj$pcd
performance.obj$value.s

# proportion of correctly (C.) selected treatment effect modifiers:
sum(mc.obj$alpha.coef[true.alpha!=0]!= 0) /sum(true.alpha!=0);
# proportion of covariates incorrectly (I.C.) selected as treatment effect modifiers:
sum(mc.obj$alpha.coef[!(true.alpha!=0)]!= 0)/ sum(true.alpha==0);

## 3. fit a system of K separate sparse addtive models, one for each treatment group
#K.SAM.obj <- K.SAM(y.train, Tr.train, X.train)
#pred.test <- pred.K.SAM(K.SAM.obj, X.test)$pred.new
#performance.obj <- performance_measure(pred.test, y.test, Tr.test, value.opt, optTr)
#performance.obj$pcd
#performance.obj$value.s
}
\seealso{
\code{pred.csim},  \code{fit.csim},  \code{fit.csim.cv}
}
\author{
Park, Petkova, Tarpey, Ogden
}
